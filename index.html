<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>C172M — Route, Turnback Safety, T/O & Mass & Balance</title>
  <style>
    body { font-family:-apple-system, system-ui, sans-serif; margin:0; padding:1rem; color:#111; }
    h1 { font-size:1.2rem; margin:0 0 .4rem 0; }
    h2 { font-size:1rem; margin:0 0 .3rem 0; }

    .card { border:1px solid #ddd; border-radius:8px; padding:.8rem; margin-bottom:1rem; box-shadow:0 1px 3px rgba(0,0,0,.06); }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:.5rem .8rem; }
    @media (max-width:650px){ .grid{ grid-template-columns:1fr; } }

    label { display:block; margin-top:.4rem; font-size:.9rem; }
    input, textarea, select, button { width:100%; padding:.4rem; margin-top:.15rem; font-size:1rem; box-sizing:border-box; }
    textarea { min-height:3rem; font-family:-apple-system, system-ui, sans-serif; }

    .btn { border:none; border-radius:6px; padding:.55rem; cursor:pointer; margin-top:.6rem; }
    .primary { background:#0b6efd; color:#fff; }
    .secondary { background:#e9ecef; color:#111; }

    a.btn { text-decoration:none; display:inline-block; text-align:center; }

    .small { font-size:.85rem; color:#444; }
    .result { margin-top:.5rem; font-weight:600; }
    .warning { font-size:.8rem; color:#b00020; margin-top:.5rem; }

    pre { font-size:.8rem; white-space:pre-wrap; margin-top:.3rem; }

    svg { width:100%; height:170px; background:#fafafa; border-radius:6px; margin-top:.4rem; }
  </style>
</head>
<body>
<h1>C172M — Route, Turnback Safety, T/O &amp; Mass &amp; Balance (Reggio Emilia)</h1>
<p class="small">
  Campo: Reggio Emilia (elev 152 ft). Aereo: C172M MTOW 2300 lb, best glide 65 kt, bank max 30°.<br>
  <strong>USO DIDATTICO — non per decisioni operative reali.</strong>
</p>

<!-- ================= ROUTE ================= -->
<div class="card">
  <h2>Route planning (Italy — direct)</h2>
  <p class="small">
    Dept/Dest per tutti gli aeroporti Italia (da <code>airports_it.csv</code>).<br>
    Vento in cruise dal modello GFS (Open-Meteo) sul punto medio rotta.<br>
    METAR degli aeroporti entro ~25 NM dalla track ricavati via AVWX.
  </p>

  <div class="grid">
    <div>
      <label for="depIcao">Departure ICAO</label>
      <input id="depIcao" type="text" placeholder="LIDE" />
    </div>
    <div>
      <label for="destIcao">Destination ICAO</label>
      <input id="destIcao" type="text" placeholder="LIPE" />
    </div>
    <div>
      <label for="tasCruise">TAS cruise (kt)</label>
      <input id="tasCruise" type="number" value="100" />
    </div>
    <div>
      <label for="cruiseAlt">Cruise altitude (ft AMSL)</label>
      <input id="cruiseAlt" type="number" value="3000" />
    </div>
    <div>
      <label for="offBlockTime">Off-block time (HH:MM locale)</label>
      <input id="offBlockTime" type="text" placeholder="16:00" />
    </div>
    <div>
      <label for="circuitHeight">Circuit height above field (ft)</label>
      <input id="circuitHeight" type="number" value="1000" />
    </div>
  </div>

  <button class="btn primary" onclick="computeRoute()">Calcola rotta</button>

  <pre id="routeOutput"></pre>
</div>

<!-- ============ NOTAM (briefing, solo stringa ICAO) ============ -->
<div class="card">
  <h2>NOTAM — briefing (fonti ufficiali)</h2>
  <p class="small">
    L’app non scarica NOTAM via API (limitazioni tecniche/costi).<br>
    Usa i link qui sotto per aprire i sistemi ufficiali, con i codici della tua rotta già pronti.
  </p>

  <p class="small" id="notamRouteInfo">
    Nessuna rotta calcolata. Calcola prima la rotta (DEP/DEST).
  </p>

  <button class="btn secondary" onclick="copyNotamRoute()">
    Copia stringa ICAO per NOTAM
  </button>

  <div style="margin-top:.5rem; display:flex; flex-wrap:wrap; gap:.5rem;">
    <a class="btn secondary" href="https://www.enav.it" target="_blank" rel="noopener">
      Apri ENAV / AIP Italia
    </a>
    <a class="btn secondary" href="https://www.ead.eurocontrol.int" target="_blank" rel="noopener">
      Apri Eurocontrol EAD Basic
    </a>
  </div>

  <p class="small" style="margin-top:.5rem;">
    Suggerimento: incolla la stringa ICAO nei campi di ricerca dei NOTAM (DEP, DEST,
    enroute/FIR) nei portali ufficiali.
  </p>
</div>

<!-- ============ METAR DEPT DINAMICO ============ -->
<div class="card">
  <h2>METAR DEPT (AVWX)</h2>
  <p class="small">
    Premi il pulsante per recuperare il METAR per l’aeroporto di partenza (DEP).<br>
    Logica:
    <br>• se DEP = <b>LIDE</b> (Reggio Emilia) → usa METAR <b>LIMP</b> (Parma)
    <br>• se DEP ≠ LIDE → prova METAR di <b>DEP</b>
    <br>• se non disponibile → prova METAR di <b>DEST</b> (se inserito)
    <br>• se ancora niente → fallback <b>LIMP</b>
    <br><br>
    Temperatura, QNH e vento verranno inseriti automaticamente nella sezione
    <b>Performance &amp; Safety altitude</b> qui sotto (poi li puoi sempre modificare a mano).
  </p>

  <p class="small">
    Stazione METAR usata: <span id="metarStationLabel">–</span>
  </p>

  <textarea id="metarDeptText" rows="2" style="width:100%; font-family:monospace;"></textarea>

  <button class="btn secondary" style="margin-top:.5rem;" onclick="loadMetarDept()">
    Carica METAR DEPT
  </button>
</div>

<!-- ============ WX CHART (link esterno) ============ -->
<div class="card">
  <h2>WX Chart — LOW LEVEL ITALY (MeteoAM SWLL)</h2>
  <p class="small">
    Apri la carta significativa del tempo a bassi livelli (SWLL, suolo–FL100)
    per l’area Italia dal sito ufficiale MeteoAM.
  </p>
  <button class="btn secondary" onclick="openSwllMeteoAM()">
    Apri WX Chart — LOW LEVEL ITALY (SWLL)
  </button>
</div>

<!-- ============ MASS & BALANCE ============ -->
<div class="card">
  <h2>Mass &amp; Balance — C172M</h2>
  <p class="small">
    Dati standard: empty weight <b>1518.56 lb</b>, momento <b>60 750 in·lb</b>.<br>
    Bracci (ARM) indicativi: pilota/pax front 37", pax rear 73", bag 1 95", bag 2 123", fuel 48". Fuel 6 lb/USG.
  </p>

  <div class="grid">
    <div>
      <label for="mbPilot">Pilota (lb)</label>
      <input id="mbPilot" type="number" />
    </div>
    <div>
      <label for="mbPaxFront">Pax anteriore (lb)</label>
      <input id="mbPaxFront" type="number" />
    </div>
    <div>
      <label for="mbPaxRear">Pax posteriori tot (lb)</label>
      <input id="mbPaxRear" type="number" />
    </div>
    <div>
      <label for="mbFuel">Fuel utilizzabile (USG)</label>
      <input id="mbFuel" type="number" />
    </div>
    <div>
      <label for="mbBag1">Bag area 1 (lb, max 120)</label>
      <input id="mbBag1" type="number" />
    </div>
    <div>
      <label for="mbBag2">Bag area 2 (lb, max 40)</label>
      <input id="mbBag2" type="number" />
    </div>
  </div>

  <button class="btn primary" onclick="calcMassBalance()">Calcola M&amp;B</button>
  <div id="mbOutput" class="small" style="margin-top:.4rem;"></div>
</div>

<!-- ============ PERFORMANCE & SAFETY ============ -->
<div class="card">
  <h2>Performance &amp; Safety altitude (Reggio Emilia)</h2>
  <p class="small">
    Usa T/QNH/vento (da METAR DEPT o inseriti a mano) e <strong>ultimo peso calcolato</strong> per stimare
    safety altitude turnback e distanze di decollo. Se non hai ancora calcolato la M&amp;B, assume 2300 lb (MTOW).
  </p>

  <div class="grid">
    <div>
      <label for="perfTemp">Temperatura aria (°C)</label>
      <input id="perfTemp" type="number" value="15" />
    </div>
    <div>
      <label for="perfQnh">QNH (hPa)</label>
      <input id="perfQnh" type="number" value="1013" />
    </div>
    <div>
      <label for="perfWindDir">Direzione vento FROM (°)</label>
      <input id="perfWindDir" type="number" placeholder="080" />
    </div>
    <div>
      <label for="perfWindSpeed">Intensità vento (kt)</label>
      <input id="perfWindSpeed" type="number" placeholder="8" />
    </div>
    <div>
      <label for="runway">Pista</label>
      <select id="runway">
        <option value="11">RWY 11 (109°)</option>
        <option value="29">RWY 29 (289°)</option>
      </select>
    </div>
    <div>
      <label for="units">Unità distanza</label>
      <select id="units">
        <option value="ft">ft</option>
        <option value="m">m</option>
      </select>
    </div>
  </div>

  <button class="btn secondary" onclick="calcPerformance()">Calcola performance + safety</button>

  <div id="perfBlock" style="display:none;">
    <div id="safetyAltText" class="result"></div>
    <div id="commentText" class="small" style="margin-top:.3rem;"></div>
    <div class="small" id="distanceText" style="margin-top:.4rem;"></div>

    <svg id="runwaySvg" viewBox="0 0 1000 200" preserveAspectRatio="xMidYMid meet">
      <rect x="20" y="70" width="960" height="60" rx="6" fill="#222" opacity="0.05"></rect>
      <g id="centerline"></g>
      <g id="markers"></g>
      <g id="labels"></g>
    </svg>

    <pre id="calcDetails"></pre>
    <div class="warning">
      TOOL DIDATTICO — sempre verificare con POH/AFM e con un istruttore.
    </div>
  </div>
</div>

<script>
/* ========== GLOBALI ========== */
let AIRPORTS_IT = null;
let lastWeightLb = 2300; // default MTOW

// C172M real aircraft (dal nuovo libretto)
const EMPTY_WEIGHT_LB    = 1518.56;  // lb
const EMPTY_MOMENT_INLB  = 60750;    // in·lb

// Token AVWX (inserito da te)
const AVWX_TOKEN = 'Z40mhXflUZEQ_xWPCMktcJz5kXX9mBAdBJsY_Jsv6wc';

/* ========== HELPER ========== */
function deg2rad(d){ return d * Math.PI / 180; }
function rad2deg(r){ return r * 180 / Math.PI; }

/* ========== CARICAMENTO AIRPORTS ========== */
async function loadAirports() {
  if (AIRPORTS_IT) return;
  try {
    const res = await fetch('airports_it.csv');
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const text = await res.text();
    AIRPORTS_IT = parseAirportsCsv(text);
  } catch (e) {
    console.error('Errore airports_it.csv', e);
    alert('Impossibile caricare airports_it.csv (controlla che sia nel repo).');
  }
}

function parseAirportsCsv(csv) {
  const lines = csv.split(/\r?\n/).filter(l => l.trim().length);
  const header = lines.shift().split(',');
  const idxIcao = header.indexOf('icao');
  const idxName = header.indexOf('name');
  const idxLat  = header.indexOf('lat');
  const idxLon  = header.indexOf('lon');
  const idxElev = header.indexOf('elev_ft');
  const db = {};
  lines.forEach(line => {
    const p = line.split(',');
    if (p.length < 5) return;
    const icao = p[idxIcao].trim().toUpperCase();
    if (!icao) return;
    db[icao] = {
      icao,
      name: p[idxName].trim(),
      lat: parseFloat(p[idxLat]),
      lon: parseFloat(p[idxLon]),
      elev_ft: parseFloat(p[idxElev]) || 0
    };
  });
  return db;
}

/* ========== GEODESIA + VENTO ========== */
function gcDistanceAndTrack(lat1, lon1, lat2, lon2) {
  const R_nm = 3440.065;
  const φ1 = deg2rad(lat1), φ2 = deg2rad(lat2);
  const Δφ = deg2rad(lat2 - lat1);
  const Δλ = deg2rad(lon2 - lon1);

  const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distNm = R_nm * c;

  const y = Math.sin(Δλ)*Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
  let track = rad2deg(Math.atan2(y,x));
  if (track < 0) track += 360;

  return { distNm, trackTrue: track };
}

// mag var approx Italia: 3°E → MAG = TRUE - 3
function trueToMag(tc){
  let mag = tc - 3;
  if (mag < 0) mag += 360;
  return mag;
}

function choosePressureLevel(cruiseAltFt) {
  if (cruiseAltFt < 4000)  return { level:"900", approx:"~3000 ft" };
  if (cruiseAltFt < 7000)  return { level:"800", approx:"~6000 ft" };
  if (cruiseAltFt < 11000) return { level:"700", approx:"~10000 ft" };
  return { level:"600", approx:"~14000 ft" };
}

async function fetchCruiseWind(lat, lon, cruiseAltFt) {
  const cfg = choosePressureLevel(cruiseAltFt);
  const spdKey = "wind_speed_" + cfg.level + "hPa";
  const dirKey = "wind_direction_" + cfg.level + "hPa";

  const url =
    "https://api.open-meteo.com/v1/gfs" +
    "?latitude=" + lat.toFixed(4) +
    "&longitude=" + lon.toFixed(4) +
    "&hourly=" + spdKey + "," + dirKey +
    "&forecast_hours=1&wind_speed_unit=kn";

  const res = await fetch(url);
  if (!res.ok) throw new Error("Open-Meteo HTTP " + res.status);
  const data = await res.json();
  const h = data.hourly || {};
  const spdArr = h[spdKey];
  const dirArr = h[dirKey];
  if (!spdArr || !dirArr || !spdArr.length || !dirArr.length) {
    throw new Error("dati vento mancanti");
  }
  return {
    windSpd: spdArr[0],
    windDir: dirArr[0],
    level: cfg.level,
    approxAlt: cfg.approx
  };
}

// vento dato come FROM
function windCorrection(courseDeg, tas, windFromDeg, windSpd) {
  const beta = deg2rad(windFromDeg - courseDeg);
  const ratio = windSpd / tas;
  const sinDrift = ratio * Math.sin(beta);
  const driftRad = Math.asin(Math.max(-1, Math.min(1, sinDrift)));
  const driftDeg = rad2deg(driftRad);
  const headingDeg = (courseDeg + driftDeg + 360) % 360;
  const gs = tas * Math.cos(driftRad) - windSpd * Math.cos(beta);
  return { driftDeg, headingDeg, gs };
}

/* ========== METAR via AVWX ========== */
async function fetchMetarText(icao) {
  if (!AVWX_TOKEN) return null;
  try {
    const url =
      'https://avwx.rest/api/metar/' +
      encodeURIComponent(icao) +
      '?format=json&token=' +
      encodeURIComponent(AVWX_TOKEN);

    const res = await fetch(url);
    if (!res.ok) {
      console.warn('AVWX HTTP', res.status, 'per', icao);
      return null;
    }
    const data = await res.json();
    return data.raw || null;
  } catch (e) {
    console.error('Errore METAR', icao, e);
    return null;
  }
}

/* ========== METAR DEPT DINAMICO ========== */
async function loadMetarDept() {
  const depInput = document.getElementById('depIcao');
  const destInput = document.getElementById('destIcao');
  const metarBox = document.getElementById('metarDeptText');
  const stationLabel = document.getElementById('metarStationLabel');

  if (!AVWX_TOKEN) {
    alert('AVWX_TOKEN non impostato nel codice.');
    return;
  }

  const dep = (depInput?.value || 'LIDE').trim().toUpperCase() || 'LIDE';
  const dest = (destInput?.value || '').trim().toUpperCase();

  const tryList = [];
  if (dep === 'LIDE') {
    tryList.push('LIMP');
  } else {
    tryList.push(dep);
  }
  if (dest && !tryList.includes(dest)) tryList.push(dest);
  if (!tryList.includes('LIMP')) tryList.push('LIMP');

  let metarRaw = null;
  let usedStation = null;

  for (const icao of tryList) {
    const raw = await fetchMetarText(icao);
    if (raw) {
      metarRaw = raw;
      usedStation = icao;
      break;
    }
  }

  if (!metarRaw) {
    metarBox.value = '';
    stationLabel.textContent = 'Nessuna stazione METAR trovata';
    alert('Impossibile recuperare un METAR per DEP/DEST. Controlla la connessione o il token AVWX.');
    return;
  }

  metarBox.value = metarRaw;
  stationLabel.textContent = usedStation + ' (via AVWX)';

  applyMetarToPerformance(metarRaw);
}

function applyMetarToPerformance(raw) {
  if (!raw || typeof raw !== 'string') return;
  const t = raw.toUpperCase();

  // es. 15/08 o M03/M07
  let tempC = null;
  const tempMatch = t.match(/ (\-?M?\d{2})\/(M?\d{2}) /);
  if (tempMatch) {
    let ts = tempMatch[1];
    if (ts.startsWith('M')) ts = '-' + ts.slice(1);
    tempC = parseInt(ts,10);
  }

  // QNH es. Q1018
  let qnh = null;
  const qMatch = t.match(/ Q(\d{4})/);
  if (qMatch) qnh = parseInt(qMatch[1],10);

  // Vento es. 08008KT o VRB03KT
  let windDir = null;
  let windSpd = null;
  const wMatch = t.match(/ (VRB|\d{3})(\d{2})KT/);
  if (wMatch) {
    if (wMatch[1] !== 'VRB') windDir = parseInt(wMatch[1],10);
    windSpd = parseInt(wMatch[2],10);
  }

  const tField   = document.getElementById('perfTemp');
  const qField   = document.getElementById('perfQnh');
  const wdField  = document.getElementById('perfWindDir');
  const wsField  = document.getElementById('perfWindSpeed');

  if (tField && tempC !== null && !Number.isNaN(tempC))  tField.value = tempC;
  if (qField && qnh   !== null && !Number.isNaN(qnh))    qField.value = qnh;
  if (wdField && windDir !== null && !Number.isNaN(windDir))
    wdField.value = windDir.toString().padStart(3,'0');
  if (wsField && windSpd !== null && !Number.isNaN(windSpd))
    wsField.value = windSpd;
}

/* ========== METAR lungo rotta (solo aeroporti con METAR) ========== */
function findMetarAlongRoute(dep, dest, maxDistNm) {
  if (!AIRPORTS_IT) return [];
  const R_nm = 3440.065;
  const lat0 = deg2rad((dep.lat + dest.lat)/2);
  const lon0 = deg2rad((dep.lon + dest.lon)/2);

  function toXY(lat, lon) {
    const φ = deg2rad(lat), λ = deg2rad(lon);
    const x = (λ - lon0) * Math.cos(lat0) * R_nm;
    const y = (φ - lat0) * R_nm;
    return { x, y };
  }

  const A = toXY(dep.lat, dep.lon);
  const B = toXY(dest.lat, dest.lon);
  const ABx = B.x - A.x;
  const ABy = B.y - A.y;
  const ab2 = ABx*ABx + ABy*ABy || 1;

  const out = [];
  for (const icao in AIRPORTS_IT) {
    if (!AIRPORTS_IT.hasOwnProperty(icao)) continue;
    const ap = AIRPORTS_IT[icao];
    if (icao === dep.icao || icao === dest.icao) continue;

    const P = toXY(ap.lat, ap.lon);
    const APx = P.x - A.x;
    const APy = P.y - A.y;
    const t = (APx*ABx + APy*ABy) / ab2;
    if (t < 0 || t > 1) continue;

    const projx = A.x + t*ABx;
    const projy = A.y + t*ABy;
    const dx = P.x - projx;
    const dy = P.y - projy;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist <= maxDistNm) {
      out.push({ icao: ap.icao, name: ap.name, dist: dist, t: t });
    }
  }

  out.sort((a,b) => a.t - b.t);
  return out.slice(0,15);
}

/* ========== NOTAM stringa info ========== */
function updateNotamRouteInfo(depId, destId, enrouteList) {
  const p = document.getElementById('notamRouteInfo');
  if (!p) return;

  if (!depId || !destId) {
    p.textContent = 'Nessuna rotta calcolata. Calcola prima la rotta (DEP/DEST).';
    return;
  }

  const extra = (enrouteList && enrouteList.length)
    ? ' / enroute: ' + enrouteList.map(a => a.icao).join(', ')
    : '';

  p.textContent = `Rotta per NOTAM: DEP ${depId} → DEST ${destId}${extra}`;
}

function copyNotamRoute() {
  const p = document.getElementById('notamRouteInfo');
  if (!p) return;
  const text = p.textContent || '';
  if (!navigator.clipboard) {
    alert('Clipboard non disponibile, copia a mano:\n\n' + text);
    return;
  }
  navigator.clipboard.writeText(text)
    .then(() => alert('Stringa NOTAM copiata negli appunti.'))
    .catch(() => alert('Impossibile copiare negli appunti, copia a mano:\n\n' + text));
}

/* ========== ROUTE MAIN ========== */
async function computeRoute() {
  const out = document.getElementById('routeOutput');
  out.textContent = '';

  await loadAirports();
  if (!AIRPORTS_IT) return;

  const depId  = document.getElementById('depIcao').value.trim().toUpperCase();
  const destId = document.getElementById('destIcao').value.trim().toUpperCase();
  const tas = parseFloat(document.getElementById('tasCruise').value);
  const cruiseAlt = parseFloat(document.getElementById('cruiseAlt').value);
  const offBlockStr = document.getElementById('offBlockTime').value.trim();
  const circuitH = parseFloat(document.getElementById('circuitHeight').value) || 1000;

  if (!depId || !destId || !tas || !cruiseAlt) {
    out.textContent = 'Inserisci DEP, DEST, TAS e quota cruise.';
    return;
  }

  const dep  = AIRPORTS_IT[depId];
  const dest = AIRPORTS_IT[destId];
  if (!dep || !dest) {
    out.textContent = 'ICAO non trovati in airports_it.csv.';
    return;
  }

  const gc = gcDistanceAndTrack(dep.lat, dep.lon, dest.lat, dest.lon);
  const distNm = gc.distNm;
  const trackT = gc.trackTrue;
  const trackM = trueToMag(trackT);

  const midLat = (dep.lat + dest.lat)/2;
  const midLon = (dep.lon + dest.lon)/2;

  let windText, windDir, windSpd;
  try {
    const w = await fetchCruiseWind(midLat, midLon, cruiseAlt);
    windDir = w.windDir;
    windSpd = w.windSpd;
    windText = `Wind (GFS Open-Meteo) @ ${w.approxAlt} (level ${w.level} hPa): FROM ≈ ${Math.round(windDir)}° / ${Math.round(windSpd)} kt`;
  } catch (e) {
    console.error(e);
    windDir = 0;
    windSpd = 0;
    windText = 'ATTENZIONE: vento modello non disponibile, usato 0 kt.';
  }

  const wc = windCorrection(trackT, tas, windDir, windSpd);
  const gs = Math.max(40, wc.gs);
  const eetH = distNm / gs;
  const eetMin = Math.round(eetH * 60);

  let etaStr = 'n/a';
  const m = offBlockStr.match(/^(\d{1,2}):(\d{2})$/);
  if (m) {
    let h = parseInt(m[1],10), min = parseInt(m[2],10);
    let tot = h*60 + min + eetMin;
    tot = ((tot%(24*60)) + 24*60)%(24*60);
    const hh = Math.floor(tot/60);
    const mm = tot%60;
    etaStr = (''+hh).padStart(2,'0') + ':' + (''+mm).padStart(2,'0');
  }

  const depElev = dep.elev_ft || 0;
  const destElev = dest.elev_ft || 0;
  const circuitAlt = destElev + circuitH;

  let tocText, todText;
  const deltaClimb = Math.max(0, cruiseAlt - depElev);
  if (deltaClimb > 0) {
    const roc = 700;
    const tMin = deltaClimb / roc;
    const gsClimb = tas * 0.8;
    const dNm = gsClimb * (tMin/60);
    tocText = `TOC: +${Math.round(deltaClimb)} ft (~${tMin.toFixed(1)} min, ≈${dNm.toFixed(1)} NM da DEP)`;
  } else {
    tocText = 'TOC: nessuna salita (cruise ≤ elev DEP)';
  }

  const deltaDescent = Math.max(0, cruiseAlt - circuitAlt);
  if (deltaDescent > 0) {
    const rod = 500;
    const tMin = deltaDescent / rod;
    const dNm = tas * (tMin/60);
    todText = `TOD: -${Math.round(deltaDescent)} ft (~${tMin.toFixed(1)} min, ≈${dNm.toFixed(1)} NM prima di DEST, per circuit alt ≈ ${Math.round(circuitAlt)} ft)`;
  } else {
    todText = 'TOD: nessuna discesa (cruise ≤ circuit alt DEST)';
  }

  let txt = '';
  txt += `DEP: ${depId} (${dep.name}), elev ${Math.round(depElev)} ft\n`;
  txt += `DEST: ${destId} (${dest.name}), elev ${Math.round(destElev)} ft\n\n`;
  txt += `Distance (GC): ${distNm.toFixed(1)} NM\n`;
  txt += `Track TRUE: ${trackT.toFixed(0)}°\n`;
  txt += `Track MAG (~3°E): ${trackM.toFixed(0)}°\n\n`;
  txt += windText + '\n';
  txt += `Heading TRUE (wind corr): ${wc.headingDeg.toFixed(0)}° (drift ${wc.driftDeg.toFixed(1)}°)\n`;
  txt += `GS stimata: ${gs.toFixed(1)} kt\n\n`;
  txt += `EET ≈ ${eetMin} min   ETA: ${etaStr}\n\n`;
  txt += tocText + '\n' + todText + '\n';

  // aeroporti entro 25 NM e METAR disponibili
  const metarStations = findMetarAlongRoute(dep, dest, 25);
  updateNotamRouteInfo(depId, destId, metarStations);

  if (metarStations.length && AVWX_TOKEN) {
    txt += `\nMETAR (aeroporti entro ~25 NM dalla rotta, solo se disponibili):\n`;
    let anyMetar = false;

    for (const s of metarStations) {
      const raw = await fetchMetarText(s.icao);
      if (raw) {
        anyMetar = true;
        txt += `- ${s.icao}: ${raw}\n`;
      }
    }

    if (!anyMetar) {
      txt += '(Nessun METAR disponibile per gli aeroporti trovati.)\n';
    }
  } else if (metarStations.length && !AVWX_TOKEN) {
    txt += `\nAeroporti entro 25 NM (configura AVWX_TOKEN per vedere i METAR): `;
    txt += metarStations.map(s => s.icao).join(', ') + '\n';
  } else {
    txt += `\nNessun aerodromo entro 25 NM nel database.\n`;
  }

  txt += `\nNota: vento modellistico Open-Meteo e METAR via AVWX (uso didattico).`;
  out.textContent = txt;
}

/* ========== MASS & BALANCE ========== */
function calcMassBalance() {
  const pilot = parseFloat(document.getElementById('mbPilot').value) || 0;
  const paxF  = parseFloat(document.getElementById('mbPaxFront').value) || 0;
  const paxR  = parseFloat(document.getElementById('mbPaxRear').value) || 0;
  const fuelG = parseFloat(document.getElementById('mbFuel').value) || 0;
  const bag1  = parseFloat(document.getElementById('mbBag1').value) || 0;
  const bag2  = parseFloat(document.getElementById('mbBag2').value) || 0;

  const arms = { pilot:37, paxR:73, bag1:95, bag2:123, fuel:48 };
  const fuelLb = fuelG * 6;

  const ew    = EMPTY_WEIGHT_LB;
  const ewMom = EMPTY_MOMENT_INLB;

  const totalW =
    ew + pilot + paxF + paxR + bag1 + bag2 + fuelLb;

  const totalM =
    ewMom +
    pilot*arms.pilot +
    paxF*arms.pilot +
    paxR*arms.paxR +
    bag1*arms.bag1 +
    bag2*arms.bag2 +
    fuelLb*arms.fuel;

  const cg = totalM / totalW;

  lastWeightLb = totalW;

  let cgMsg = 'CG stimato dentro inviluppo approssimato (35"–47").';
  if (cg < 35 || cg > 47) cgMsg = 'ATTENZIONE: CG stimato fuori inviluppo approssimato (35"–47").';

  const mtowMsg = totalW > 2300 ? 'ATTENZIONE: oltre MTOW (2300 lb).' : 'Peso ≤ MTOW.';

  const txt =
    `Peso totale stimato: ${Math.round(totalW)} lb
CG stimato: ${cg.toFixed(1)} in
Fuel: ${fuelG.toFixed(1)} USG (${Math.round(fuelLb)} lb)
${cgMsg}
${mtowMsg}`;

  document.getElementById('mbOutput').textContent = txt;
}

/* ========== PERFORMANCE & SAFETY ALT ========== */
function calcPerformance() {
  const temp = parseFloat(document.getElementById('perfTemp').value);
  const qnh  = parseFloat(document.getElementById('perfQnh').value);
  const windDir = parseFloat(document.getElementById('perfWindDir').value);
  const windSpd = parseFloat(document.getElementById('perfWindSpeed').value);
  const runway  = document.getElementById('runway').value;
  const units   = document.getElementById('units').value;

  if ([temp,qnh,windDir,windSpd].some(v => isNaN(v))) {
    alert('Inserisci T, QNH, vento (dir/int) o carica il METAR DEPT.');
    return;
  }

  const fieldElev = 152;
  const baseSafety = 900;
  const baseRoll = 835;
  const base50  = 1475;
  const rwyLen_m = 1210;
  const rwyLen_ft = Math.round(rwyLen_m * 3.28084);
  const weight = lastWeightLb || 2300;
  const wRef = 2300;

  const pa = fieldElev + (1013 - qnh)*30;
  const isaT = 15 - 2*(fieldElev/1000);
  const da = pa + 120*(temp - isaT);
  const daDiff = da - fieldElev;

  const daFactorSafety = 1 + 0.10*(daDiff/1000);
  let daFactorDist = 1 + 0.12*(daDiff/1000);

  let wFactorSafety = Math.min(1.2, Math.max(0.85, weight/wRef));
  let wFactorDist   = Math.min(1.3, Math.max(0.7, (weight/wRef)*(weight/wRef)));

  const rwyHeading = runway === '11' ? 109 : 289;
  const ang = deg2rad(rwyHeading - windDir);
  const headwind = windSpd * Math.cos(ang); // >0 headwind, <0 tailwind

  let windFactorSafety = 1;
  if (headwind < 0) {
    const tail = -headwind;
    windFactorSafety = 1 + 0.10*(tail/10);
  } else {
    const head = headwind;
    windFactorSafety = 1 - 0.05*(head/10);
    if (windFactorSafety < 0.8) windFactorSafety = 0.8;
  }

  let windFactorDist = 1;
  if (headwind < 0) {
    const tail = -headwind;
    windFactorDist = 1 + 0.05*(tail/5);
  } else {
    const head = headwind;
    windFactorDist = 1 - 0.05*(head/5);
    if (windFactorDist < 0.7) windFactorDist = 0.7;
  }

  const distFactor = daFactorDist*windFactorDist*wFactorDist;
  const rollAdj_ft = baseRoll*distFactor;
  const fiftyAdj_ft= base50*distFactor;

  const safetyCalc = baseSafety*daFactorSafety*windFactorSafety*wFactorSafety;
  const safetyRounded = Math.round(safetyCalc/10)*10;
  const safetySuggested = Math.max(baseSafety, safetyRounded);

  const unitsLabel = units === 'ft' ? 'ft' : 'm';
  const conv = v => units === 'ft' ? Math.round(v)
                                   : Math.round(v*0.3048*10)/10;

  const safText =
    `Safety altitude teorica (peso ≈ ${Math.round(weight)} lb): ${safetyRounded} ft AGL.
Minimo operativo suggerito: ${safetySuggested} ft AGL (standard Reggio ${baseSafety} ft).`;

  document.getElementById('safetyAltText').textContent = safText;

  let comment;
  if (safetyRounded <= baseSafety) {
    comment = 'Teoricamente possibile una safety altitude uguale/inferiore allo standard. In addestramento mantieni comunque 900 ft come minima per il turnback.';
  } else if (safetyRounded < 1100) {
    comment = 'Safety altitude leggermente sopra lo standard: DA/vento/peso un po’ penalizzanti. Margini ridotti, valutare con istruttore.';
  } else {
    comment = 'Safety altitude alta: condizioni sfavorevoli (DA, tailwind e/o peso). Turnback poco consigliabile salvo training specifico.';
  }
  document.getElementById('commentText').textContent = comment;

  const distText =
`POH base (10°C, QNH 1013, no wind, 2300 lb):
- Ground roll = ${baseRoll} ft (${Math.round(baseRoll*0.3048)} m)
- 50 ft obstacle = ${base50} ft (${Math.round(base50*0.3048)} m)

Corretto (DA≈${Math.round(da)} ft, headwind≈${headwind.toFixed(1)} kt, peso≈${Math.round(weight)} lb):
- Ground roll ≈ ${conv(rollAdj_ft)} ${unitsLabel}
- 50 ft obstacle ≈ ${conv(fiftyAdj_ft)} ${unitsLabel}
Runway length: ${rwyLen_ft} ft (${rwyLen_m} m).`;

  document.getElementById('distanceText').textContent = distText;

  const details =
`Pressure altitude ≈ ${Math.round(pa)} ft
ISA temp campo ≈ ${isaT.toFixed(1)} °C
Density altitude ≈ ${Math.round(da)} ft
DA factor (dist) ≈ ${daFactorDist.toFixed(2)}
Weight factor (dist) ≈ ${wFactorDist.toFixed(2)}
Wind factor (dist) ≈ ${windFactorDist.toFixed(2)}
Headwind effettivo ≈ ${headwind.toFixed(1)} kt
DA factor (safety) ≈ ${daFactorSafety.toFixed(2)}
Weight factor (safety) ≈ ${wFactorSafety.toFixed(2)}
Wind factor (safety) ≈ ${windFactorSafety.toFixed(2)}
Roll adj ≈ ${Math.round(rollAdj_ft)} ft
50 ft adj ≈ ${Math.round(fiftyAdj_ft)} ft`;
  document.getElementById('calcDetails').textContent = details;

  drawRunwayDiagram(rollAdj_ft, fiftyAdj_ft, rwyLen_ft, units);
  document.getElementById('perfBlock').style.display = 'block';
}

/* ========== RUNWAY SVG ========== */
function drawRunwayDiagram(roll_ft, fifty_ft, rwy_ft, units) {
  const svg = document.getElementById('runwaySvg');
  const center = svg.querySelector('#centerline');
  const markers= svg.querySelector('#markers');
  const labels = svg.querySelector('#labels');
  while (center.firstChild) center.removeChild(center.firstChild);
  while (markers.firstChild) markers.removeChild(markers.firstChild);
  while (labels.firstChild) labels.removeChild(labels.firstChild);

  const marginLeft = 20;
  const usableW = 960;
  const pxPerFt = usableW / rwy_ft;

  const rollPx  = Math.max(8, Math.min(roll_ft,  rwy_ft)*pxPerFt);
  const fiftyPx = Math.min(fifty_ft, rwy_ft)*pxPerFt;

  // centerline
  let x = marginLeft+8;
  const dash = 14, gap = 10;
  while (x < marginLeft+usableW-8) {
    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1', x); l.setAttribute('y1', 100);
    l.setAttribute('x2', x+dash); l.setAttribute('y2', 100);
    l.setAttribute('stroke', '#aaa'); l.setAttribute('stroke-width', '2');
    center.appendChild(l);
    x += dash+gap;
  }

  const rollRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
  rollRect.setAttribute('x', marginLeft+6);
  rollRect.setAttribute('y', 58);
  rollRect.setAttribute('width', rollPx);
  rollRect.setAttribute('height', 24);
  rollRect.setAttribute('fill', '#0b6efd');
  rollRect.setAttribute('opacity', '0.35');
  markers.appendChild(rollRect);

  const line50 = document.createElementNS('http://www.w3.org/2000/svg','line');
  const x50 = marginLeft+6+fiftyPx;
  line50.setAttribute('x1', x50);
  line50.setAttribute('y1', 40);
  line50.setAttribute('x2', x50);
  line50.setAttribute('y2', 140);
  line50.setAttribute('stroke', '#b00020');
  line50.setAttribute('stroke-width', '2');
  markers.appendChild(line50);

  function addLabel(text,x,y,anchor) {
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', x); t.setAttribute('y', y);
    t.setAttribute('fill', '#222');
    t.setAttribute('font-size', '12');
    t.setAttribute('text-anchor', anchor || 'middle');
    t.textContent = text;
    labels.appendChild(t);
  }

  const unitLabel = units === 'ft' ? 'ft' : 'm';
  const conv = v => units === 'ft' ? Math.round(v) : Math.round(v*0.3048*10)/10;

  addLabel(`Ground roll ≈ ${conv(roll_ft)} ${unitLabel}`,
           marginLeft+6+rollPx/2, 52, 'middle');
  addLabel(`50 ft ≈ ${conv(fifty_ft)} ${unitLabel}`,
           x50, 34, 'middle');
  addLabel('Threshold', marginLeft+6, 170, 'start');
  addLabel('Runway end', marginLeft+usableW, 170, 'end');
  addLabel(`${Math.round(rwy_ft)} ft RWY`, marginLeft+usableW/2, 170, 'middle');
}

/* ========== WX CHART BUTTON ========== */
function openSwllMeteoAM() {
  // URL generale MeteoAM (puoi sostituirlo con il link diretto alla SWLL che usi tu)
  const url = 'https://www.meteoam.it';
  window.open(url, '_blank');
}
</script>
</body>
</html>
